---
layout: post
title: "tidyr HOW-TO"
permalink: tidyr-how-to
---

Большой проблемой в `R` остается отсутствие общепринятого стандарта оформления кода. Разные аторы используют разные подходы, какие-то распространены шире, какие-то уже, добавим сюда огромное количество пакетов и плохую память и получим кашу в голове. Лично я не отличаюсь острой памятью, поэтому уже давно оформляю для себя `markdown`-шпаргалки по самым часто используемым пакетам, привлекая к этой работе и коллег. Безусловно это не идельный вариант ведения такого рода документации, но он неплохо помогает лично мне, поэтому было решено по-тихоньку причесать все документы и выложить отдельными постами. Начнем с пакета `tidyr`.

# Оглавление

1. [expand()][]
2. [extract()][]
3. [extract_numeric()][]
4. [gather()][]
5. [separate()][]
6. [seq_range()][]
7. [spread()][]
8. [unit()][]
9. [unnest()][]

# Общее

Пакет `tidyr` за авторством Hadley Wickham'а предназначен для первичной обработки сырых данных, в частности изменения их структуры. Для начала нам потребуются сам `tidyr`, а также `dplyr`:
```{r message=FALSE}
library(tidyr)
library(dplyr)
```

# expand()
## Назначение

Создает `data.frame` включающий все комбинации заданных переменных без перестановок

## Использование

`expand(data, ...)`

## Аргументы

- `data` - оригинальный `data.frame`
- `...` - имена переменных для комбинации (допустимы выражения вместо непосредственно имен)

## Примеры использования

Данные:
```{r}
df <- data.frame(a = c(1, 2, 5), b = c(3, 5, 3), c = c(1, 2, 3))
df
```

Все комбинации переменных `vs` и `cyl`:
```{r}
expand(mtcars, vs, cyl)
```

Все комбинации переменных `cyl` и `mpg`, последняя при этом принимает только минимальное или максимальное значение:
```{r}
expand(mtcars, cyl, mpg = seq_range(mpg, 2))
```

Все комбинации переменных `cyl` и `mpg`, последняя при этом принимает значения из разбитого на 5 равных частей диапазона ([seq_range()][]):
```{r}
expand(mtcars, cyl, mpg = seq_range(mpg, 5))
```

Все комбинации переменных `a`, `b` и `c`:
```{r}
expand(df)
```

Все комбинации переменных `a` и `b`:
```{r}
expand(df, a, b)
```

Все комбинации переменных `a` и `c`:
```{r}
expand(df, a, c)
```

Все комбинации переменных `b ` и `c`:
```{r}
expand(df, b, c)
```

# extract()
## Назначение

Применяет регулярное выражение к переменной и создает одну или несколько новых на основе результата

## Использование

```
extract(data, col, into, regex = "([[:alnum:]]+)", remove = TRUE,
        convert = FALSE, ...)
```

## Аргументы

- `data` - оригинальный `data.frame`
- `col` - имя переменной
- `into` - имена новых переменных
- `regex` - регулярное выражение для поиска требуемых данных
- `remove` - если `TRUE` - удаляет `col` из результирующего `data.frame`
- `convert` - если `TRUE` - применяет `type.convert` c `as.is = TRUE` к новым переменным
- `...` - дополнительные аргументы для `regexec`

## Примеры использования

Данные:
```{r}
df <- data.frame(x = c("a.b", "a.d", "b.c"))
df
```

Извлечь из переменной `x` первую букву:
```{r}
df %>% extract(x, "A")
```

Разбить переменную `x`:
```{r}
df %>% extract(x, c("A", "B"), "([[:alnum:]]+)\\.([[:alnum:]]+)")
```

# extract_numeric()
## Назначение

Используя регулярное выражения удаляет все нецифровые знаки из строки и трансформирует результат в число

## Использование

```
extract_numeric(x)
```

## Аргументы

- `x` - `character vector` или `factor`

## Примеры использования

```{r}
extract_numeric("$1,200.34")
```

```{r}
extract_numeric("-2%")
```

Может некорректно работать со строками, которые точно не являются цифровыми данными:
```{r}
extract_numeric("-2-2")
extract_numeric("12abc34")
```

# gather()
## Назначение

Объединяет переменные, имена переменных для объединения становятся уровнями переменной `key`, значения объединенных переменных заполняют соответственно переменную `value`

## Использование

```
gather(data, key, value, ..., na.rm = FALSE, convert = FALSE)
```

## Аргументы

- `data` - оригинальный `data.frame`
- `key`, `value` - `key`, `value` переменные
- `...` - переменные для объединения, выбор нескольких: `x:z`, исключить: `-y`
- `na.rm` - если `TRUE` - удалить все `NA`
- `convert` - если `TRUE` - применяет `type.convert` к `key` переменной

## Примеры использования

Данные:
```{r}
stocks <- data.frame(
time = as.Date('2009-01-01') + 0:9,
X = rnorm(10, 0, 1),
Y = rnorm(10, 0, 2),
Z = rnorm(10, 0, 4)
)
stocks
```

Объединить имена переменных `X`, `Y`, `Z` в качестве уровней новой переменной `stock`, значения объединенных переменных заполнят переменую `price`:
```{r}
stocks %>% gather(stock, price, -time)
```

# separate()
## Назначение

Разбивает переменную на несколько

## Использование

```
separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
         convert = FALSE, extra = "error", ...)
```

## Аргументы

- `data` - оригинальный `data.frame`
- `col` - имя переменной для разбивки
- `into` - имена новых переменных
- `sep` - разделитель, если `character` - воспринимается как регулярное выражение, по-умолчанию - последовательность не цифро-буквенных знаков, если `numeric` - воспринимается как позиция для разделения
- `remove` - если `TRUE` - удаляет `col` из результирующего `data.frame`
- `convert` - если `TRUE` - применяет `type.convert` c `as.is = TRUE` к новым переменным
- `extra` - если `sep` - `character`, то аргумент задает реакцию на превышение допустимого числа новых переменных (`into`):
    - `error` - ошибка по-умолчанию
    - `drop` - возвращает `length(into)`, отбрасывает все сверху или расширяет `data.frame`
    - `merge` - разделяет только `length(into)` раз
- `...` - дополнительные переменные для `strsplit`

## Примеры использования

Данные:
```{r}
df <- data.frame(x = c("a.b", "a.d", "b.c"))
df
```

Разбить переменную `x` на две, разделитель - `.`:
```{r}
df %>% separate(x, c("A", "B"))
```

Если строки нельзя разделить на равное число переменных:
```{r}
df <- data.frame(x = c("a", "a b", "a b c"))
df %>% separate(x, c("a", "b"), extra = "merge")
df %>% separate(x, c("a", "b"), extra = "drop")
```

Данные:
```{r}
df <- data.frame(x = c("x: 123", "y: error: 7"))
df
```

Разбить строки строго на две переменные по первому включению `sep`:
```{r}
df %>% separate(x, c("key", "value"), ": ", extra = "merge")
```

# seq_range()
## Назначение

Возвращает вектор из `n` значений от минимального до максимального `x` с равными промежутками

## Использование

```
seq_range(x, n)
```

## Аргументы

- `x` - `numeric vector`
- `n` - число значений

## Примеры использования

Разобъем диапазон значений вектора `1:100`: 
```{r}
seq_range(1:100, 5)
```

# spread()
## Назначение

Переформатирует `data.frame` - используя в качестве новых переменных уровни заданной переменной `key`, заполняя таблицу соответствующими значениями переменной `value`.

## Использование

```
spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE)
```

## Аргументы

- `data` - `numeric vector`
- `key` - переменная, чьи уровни станут новыми переменными
- `value` - переменная, сответствующими значениями которой будут заполнены новые столбцы
- `fill` - елси для комбинации переменной `key` и других переменных нет значения - подставляет на его место указанное 
- `convert` - если `TRUE` - применяет `type.convert` c `as.is = TRUE` к новым переменным
- `drop` - если `FALSE` - сохранить уровни факторов, для которых нет значений в данных, заполняя их по правилу `fill`

## Примеры использования

Данные:
```{r}
stocks <- data.frame(
time = as.Date('2009-01-01') + 0:9,
X = rnorm(10, 0, 1),
Y = rnorm(10, 0, 2),
Z = rnorm(10, 0, 4)
)
stocks
```

Противоположность `gather`:
```{r}
stocksm <- stocks %>% gather(stock, price, -time)
head(stocksm)
stocksm %>% spread(stock, price)
```

Разбить `price` по переменной `time`:
```{r}
stocksm %>% spread(time, price)
```

# unit()
## Назначение

Объединяет переменные в одну

## Использование

```
unite(data, col, ..., sep = "_", remove = TRUE)
```

## Аргументы

- `data` - `numeric vector`
- `col` - имя базовой переменной
- `...` - переменные для объединения с базовой
- `sep` - разделитель между значениями объединенных переменных 
- `remove` - если `TRUE` - удаляет переменные для объединения

## Примеры использования

Объединям переменные `vs` и `am` в одну:
```{r}
mtcars %>%
  unite_("vs_am", c("vs", "am")) %>%
  head()
```

Противоположность `separate`:
```{r}
mtcars %>%
  unite(vs_am, vs, am) %>%
  separate(vs_am, c("vs", "am")) %>%
  head()
```

# unnest()
## Назначение

Разбивает переменную на большее число строк за счет раскрытия вложенных элементов

## Использование

```
unnest(data, col = NULL)
```

## Аргументы

- `data` - оригинальный `data.frame`
- `col` - переменная, которую нужно разбить на большее число строк

## Примеры использования

Данные:
```{r}
df <- data.frame(
x = 1:3,
y = c("a", "d,e,f", "g,h"),
stringsAsFactors = FALSE
)
df
```

Разбить переменную `y` на большее число строк:
```{r}
df %>%
  transform(y = strsplit(y, ",")) %>%
  unnest(y)
```

Разобъем стандартный набор данных `iris` по виду цветка:
```{r}
my_list <- lapply(split(subset(iris, select = -Species), iris$Species), "[", 1:2, )
my_list
```

Соберем список обратно в `data.frame`:
```{r}
unnest(my_list)
```

Добавим потерявшуюся переменную `Species`:
```{r}
unnest(my_list, Species)
```
